# 第四章 处理器体系结构

## 自定义指令集 Y86-64

### Y86-64 程序员可见状态

#### **RF: 程序员寄存器** 
共 15 个
| No.    | Register | No.    | Register |
|--------|----------|--------|----------|
|   0    |  `%rax`  |   8    |  `%r8`   |
|   1    |  `%rcx`  |   9    |  `%r9`   |
|   2    |  `%rdx`  |   A    |  `%r10`  |
|   3    |  `%rbx`  |   B    |  `%r11`  |
|   4    |  `%rsp`  |   C    |  `%r12`  |
|   5    |  `%rbp`  |   D    |  `%r13`  |
|   6    |  `%rsi`  |   E    |  `%r14`  |
|   7    |  `%rdi`  |   F    |  None    |


#### **CC: 条件码**
共 3 个，分别为 0标志，符号标志和溢出标志
| ZF | SF | OF |
|----|----|----|

#### **PC: 程序计数器**
存放当前执行的指令地址

#### **Stat: 程序状态**

存放程序是正常运行还是异常，任何非 AOK 的状态都会让程序停止。

| Value | Name | Meaning         |
|-------|------|-----------------|
|   1   | AOK  | 正常操作         |
|   2   | HLT  | 遇到执行 halt 指令|
|   3   | ADR  | 遇到非法地址      |
|   4   | INS  | 遇到非法指令      |


#### **DMEM: 内存**


###  Y86-64指令集

| Instruction Byte  |0   |1    |2|3|4|5|6|7|8|9|
|-------------------|----|-----|-|-|-|-|-|-|-|-|
| `halt`            |0 0 |     | | | | | | | | |
| `nop`             |1 0 |     | | | | | | | | |
| `rrmovq rA, rB`   |2 0 |rA rB| | | | | | | | |
| `irmovq V, rB`    |3 0 |F rB |V| | | | | | | |
| `rmmovq rA, D(rB)`|4 0 |rA rB|D| | | | | | | |
| `mrmovq D(rB), rA`|5 0 |rA rB|D| | | | | | | |
| `OPq rA, rB`      |6 fn|rA rB| | | | | | | | |
| `jXX Dest`        |7 fn|Dest | | | | | | | | |
| `cmovXX rA, rB`   |2 fn|rA rB| | | | | | | | |
| `call Dest`       |8 0 |Dest | | | | | | | | |
| `ret`             |9 0 |     | | | | | | | | |
| `pushq rA`        |A 0 |rA F | | | | | | | | |
| `popq rA`         |B 0 |rA F | | | | | | | | |

总长度从 1 byte 到 10 byte 不等，根据具体的指令计算。

- `halt`， 程序停止，并将程序状态码设置为 HLT
- `nop`，啥也不做，PC+1
- `xxmovq`，立即数、寄存器、内存之间移动
- `OPq`，4个整数操作指令
- `jXX`，7个分支指令
- `cmov`，6个条件移动指令
- `call`，将返回地址压入栈中，并跳转到目标地址
- `ret`，弹出返回地址，并跳转到弹出的地址
- `pushq`，将寄存器中的值压入栈中
- `popq`，将栈中的值弹出到寄存器

目标地址 Dest 为绝对地址。
所有整数采用小端法编码。


**`OPq`**
| Instruction  |    |
|--------------|----|
| `addq`       |6 0 |
| `subq`       |6 1 |
| `andq`       |6 2 |
| `xorq`       |6 3 |

**`jXX`**
| Instruction  |    |
|--------------|----|
| `jmp`        |7 0 |
| `jle`        |7 1 |
| `jl`         |7 2 |
| `je`         |7 3 |
| `jne`        |7 4 |
| `jge`        |7 5 |
| `jg`         |7 6 |

**`cmovXX`**
| Instruction  |    |
|--------------|----|
| `comvle`     |2 1 |
| `comvl`      |2 2 |
| `comve`      |2 3 |
| `comvne`     |2 4 |
| `comvge`     |2 5 |
| `comvg`      |2 6 |


## 补充

### 如何从01转换为图形

以 ASCII 码举例
1. 用户输入 65
2. 操作系统调用图形接口需要显示 'A'
3. 图形接口查找字体文件，将字符 'A' 转换为像素点
4. 显卡接收操作系统传来的绘图指令（如要显示 'A' 的像素点）
5. 显卡将这些像素点翻译成信号（如RGB值）传递给显示器
6. 显示器将图像信号渲染成颜色