## 2.5
```c
int val = 0x87654321;
byte_pointer valp = (byte_pointer) &val;
show_bytes(valp, 1); // A
show_bytes(valp, 2); // B
show_bytes(valp, 3); // C
```

|No.|littel endian| big endian|
|---|-------------|-----------|
| A |21           |87         |
| B |21 43        |87 65      |
| C |21 43 65     |87 65 43   |


## 2.6

十进制3510593 
- int  0x00359141
- float  0x4A564504

A.
- int  1101011001000101000001
- float  1001010010101100100010100000100

B. 21
C. 除了 int 的最高位不符合

## 2.18

A. sub 736
B. mov -88
C. add 40
D. mov -48
E. mov 120
F. mov 136
G. mov 504
H. mov 192
I. mov -72

## 2.19

| x  |T2U4(x)|
|----|-------|
| -8 |    8  |
| -3 |   13  |
| -2 |   14  |
| -1 |   15  |
|  0 |    0  |
|  5 |    5  |

## 2.23

A. 

|     w      |   fun1(w)   |   fun2(w)  |
|------------|-------------|------------|
| 0x00000076 | 0x00000076  | 0x00000076 |
| 0x87654321 | 0x00000021  | 0x00000021 |
| 0x000000C9 | 0x000000C9  | 0xFFFFFFC9 |
| 0xEDCBA987 | 0x00000087  | 0xFFFFFF87 |

B. fun1 提取低8位，返回 0～255。fun2 提取低8位，并带上符号，返回 -128～127。

## 2.48
单精度浮点数 3510593.0  的 16 进制表示推导：
$ (3510593)_10 = (359141)_{16} = (1101011001000101000001)_2 $
加上小数点后为 $ 1.101011001000101000001 \times 2^{21}$，
则 

$$ 
M = 0.10101100100010100000100 \\
Bias = 127 \\
E = 21+Bias = 148 = 10010100\\
s = 0 \\
$$

所以原数的2进制表示为 01001010010101100100010100000100，16进制为 0x4A564504

## 2.49

A. 因为是正整数，所以处于规格化区间，M = 1+f。
若 f 为全为 0，则必然能准确表示 2^n 的正整数；
若 f 不全为 0，当末尾为 1 时最小，此时最小值为n个0+末尾的1，即 M = 1.000...1，小数点后位数为 n+1 位，此值为 2^(n+1)+1。
